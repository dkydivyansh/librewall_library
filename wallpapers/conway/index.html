<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Conway</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black;
        }

        canvas {
            display: block;
            /* Force the canvas to visually fill the screen */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');

        // --- CONFIGURATION ---
        const cellSize = 8;
        let cols, rows;
        let grid, nextGrid;

        let mouseX = -1, mouseY = -1;

        // --- GRID FUNCTIONS ---
        function createGrid() {
            const newGrid = new Array(rows);
            for (let y = 0; y < rows; y++) {
                newGrid[y] = new Array(cols).fill(0);
            }
            return newGrid;
        }

        function seedGrid() {
            for (let i = 0; i < 5000; i++) {
                const x = Math.floor(Math.random() * cols);
                const y = Math.floor(Math.random() * rows);
                if (grid[y] && grid[y][x] !== undefined) {
                    grid[y][x] = 1;
                }
            }
        }

        // --- RESIZE LOGIC (High DPI + Auto Layout) ---
        function resize() {
            // 1. Detect Screen Scale (1.0, 1.25, 1.5, etc.)
            const dpr = window.devicePixelRatio || 1;

            // 2. Set Buffer Size (Physical Pixels) for sharpness
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;

            // 3. Scale Context so drawing math stays simple
            ctx.scale(dpr, dpr);

            // 4. Calculate Grid Columns based on Logical Size
            cols = Math.floor(window.innerWidth / cellSize);
            rows = Math.floor(window.innerHeight / cellSize);

            // 5. Rebuild Grid
            grid = createGrid();
            nextGrid = createGrid();
            seedGrid();
        }

        // Initialize
        resize();
        window.addEventListener('resize', resize);

        // --- INPUT HANDLING ---
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            // Map mouse coordinates to grid
            mouseX = Math.floor((e.clientX - rect.left) / cellSize);
            mouseY = Math.floor((e.clientY - rect.top) / cellSize);
        });

        canvas.addEventListener('mouseleave', () => {
            mouseX = -1; mouseY = -1;
            drawMouseLine.prevX = undefined;
            drawMouseLine.prevY = undefined;
        });

        canvas.addEventListener('mouseenter', () => {
            mouseX = -1; mouseY = -1;
            drawMouseLine.prevX = undefined;
            drawMouseLine.prevY = undefined;
        });

        // --- GAME LOGIC ---
        function update() {
            drawMouseLine();
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const cell = grid[y][x];
                    let neighbors = 0;

                    // Optimized Loop
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
                                neighbors += grid[ny][nx];
                            }
                        }
                    }

                    if (cell === 1 && (neighbors === 2 || neighbors === 3)) {
                        nextGrid[y][x] = 1;
                    } else if (cell === 0 && neighbors === 3) {
                        nextGrid[y][x] = 1;
                    } else {
                        nextGrid[y][x] = 0;
                    }
                }
            }
            // Swap
            let temp = grid;
            grid = nextGrid;
            nextGrid = temp;
        }

        let backgroundColor = 'black';
        let foregroundColor = 'white';

        function drawGrid() {
            // Clear using logical dimensions (since we scaled ctx)
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

            ctx.fillStyle = foregroundColor;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (grid[y][x] === 1) {
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        function newTiles() {
            if (!cols || !rows) return;
            const x = Math.floor(Math.random() * cols);
            const y = Math.floor(Math.random() * rows);
            let offset = 0;
            // Safety check for array bounds
            if (grid[y]) {
                while (x + offset < cols && grid[y][x + offset] === 0) {
                    offset++;
                }
                if (x > 0 && offset > 0 && grid[y][x + offset - 1] !== undefined) {
                    grid[y][x + offset - 1] = 1;
                }
            }
        }

        function drawMouseLine() {
            if (drawMouseLine.prevX === undefined) {
                drawMouseLine.prevX = mouseX;
                drawMouseLine.prevY = mouseY;
            }
            if (mouseX === -1 || mouseY === -1) {
                drawMouseLine.prevX = mouseX;
                drawMouseLine.prevY = mouseY;
                return;
            }
            let x0 = drawMouseLine.prevX;
            let y0 = drawMouseLine.prevY;
            let x1 = mouseX;
            let y1 = mouseY;

            let dx = Math.abs(x1 - x0);
            let dy = Math.abs(y1 - y0);
            let sx = x0 < x1 ? 1 : -1;
            let sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            while (true) {
                if (x0 >= 0 && x0 < cols && y0 >= 0 && y0 < rows) {
                    grid[y0][x0] = 1;
                }
                if (x0 === x1 && y0 === y1) break;
                let e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }

            drawMouseLine.prevX = mouseX;
            drawMouseLine.prevY = mouseY;
        }

        let frameCount = 0;
        let lastTime = 0;
        const targetFPS = 20;
        const interval = 1000 / targetFPS;

        function animate(now) {
            requestAnimationFrame(animate);

            // --- FIX: AUTO-RESIZE CHECK ---
            // If the window size changed since the last frame (e.g., engine startup finished),
            // trigger a resize immediately.
            const dpr = window.devicePixelRatio || 1;
            const currentWidth = window.innerWidth * dpr;
            const currentHeight = window.innerHeight * dpr;

            // Check if buffer matches screen (allow 1px tolerance)
            if (Math.abs(canvas.width - currentWidth) > 1 || Math.abs(canvas.height - currentHeight) > 1) {
                resize();
            }
            // ------------------------------

            if (!lastTime) lastTime = now;
            const delta = now - lastTime;
            if (delta >= interval) {
                lastTime = now - (delta % interval);
                frameCount++;
                if (frameCount % 30 === 0) {
                    newTiles();
                    newTiles();
                    newTiles();
                }
                update();
                drawGrid();
            }
        }

        function updateBackground(color) {
            backgroundColor = color
        }
        window.updateBackground = updateBackground;

        function updateForeground(color) {
            foregroundColor = color;
        }
        window.updateForeground = updateForeground;

        animate(0);
    </script>
    <script src="menu.js"></script>
</body>

</html>